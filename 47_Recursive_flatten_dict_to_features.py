# 递归展平字典, 举例见method1里的example

# 1
from typing import Dict, Any
def flatten_dict_to_featureDict(input_dict: Dict) -> Dict[str, Any]:
    """
    Description
    ----------
        将一个嵌套的字典展开为一个扁平化的字典, 适用于将复杂的嵌套字典转换为机器学习特征字典;

    Args
    ----------
        input_dict (Dict): 输入的嵌套字典;

    Returns
    ----------
        Dict: 扁平化后的字典;

    Notes
    ----------
    - 1, 为了防止展开之后的键值对冲突, 也为了便于识别新键值对的来源, 展开之后的键名使用短横线号"_"链接各级键名;
    比如说, 输入字典为 {"a": 1, "b": {"c": 2, "d": {"e": 3}}}, 则展开后的字典为 {"a": 1, "b_c": 2, "b_d_e": 3};
    - 2, 本函数假设输入字典的值要么是标量数值类型, 要么是字典类型, 不考虑其他复杂数据类型;除了字典类型之外的值均视为标量数值类型, 后续可以在展平之后再进行数据类型转换(提取之类)


    Example
    ----------
    >>> nested_dict = {
    ...     "a": 1,
    ...     "b": {
    ...         "c": 2,
    ...         "d": {
    ...             "e": 3
    ...         }
    ...     }
    ... }
    >>> flat_dict = flatten_dict_to_featureDict(nested_dict)
    >>> print(flat_dict)
    {'a': 1, 'b_c': 2, 'b_d_e': 3}
    """

    # 初始化新字典
    flat_dict = {}
    for key, value in input_dict.items():
        # 首先判断子值是否为字典
        if isinstance(value, dict):
            # 如果是则递归调用本函数然后展开为子字典
            sub_dict = flatten_dict_to_featureDict(value)
            # 假设我们获取了子字典sub_dict, 现在需要完善一下子字典的键名
            for sub_key, sub_value in sub_dict.items():
                # 使用下划线链接键名, 存到新字典中
                flat_dict[f"{key}_{sub_key}"] = sub_value
        # 如果不是字典, 暂时认为是scalar数值类型就直接添加
        else:
            flat_dict[key] = value
    return flat_dict

# 举例分析, 说明
import numpy as np
new_dict = {'length': 56, 'aa_freq': {'A': 0.017857142857142856, 'C': 0.03571428571428571, 'D': 0.0, 'E': 0.07142857142857142, 'F': 0.017857142857142856, 'G': 0.125, 'H': 0.05357142857142857, 'I': 0.03571428571428571, 'K': 0.07142857142857142, 'L': 0.03571428571428571, 'M': 0.017857142857142856, 'N': 0.03571428571428571, 'P': 0.125, 'Q': 0.03571428571428571, 'R': 0.03571428571428571, 'S': 0.10714285714285714, 'T': 0.05357142857142857, 'V': 0.07142857142857142, 'W': 0.017857142857142856, 'Y': 0.03571428571428571}, 'shannon_entropy': np.float64(3.980167084245813), 'gini_impurity': 0.926020408163265, 'charge_signal': [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1, 1, 0], 'cider_scalar': {'length': 56, 'FCR': np.float64(0.18906189935018722), 'NCPR': np.float64(0.04281928020810004), 'isoelectric_point': 8.96875, 'molecular_weight': 6078.800000000003, 'negative_number': 4, 'positive_number': 6, 'neutral_number': 46, 'fraction_positive': 0.10714285714285714, 'fraction_negative': 0.07142857142857142, 'fraction_expanding': 0.30357142857142855, 'aa_fraction': {'A': 0.017857142857142856, 'C': 0.03571428571428571, 'D': 0.0, 'E': 0.07142857142857142, 'F': 0.017857142857142856, 'G': 0.125, 'H': 0.05357142857142857, 'I': 0.03571428571428571, 'K': 0.07142857142857142, 'L': 0.03571428571428571, 'M': 0.017857142857142856, 'N': 0.03571428571428571, 'P': 0.125, 'Q': 0.03571428571428571, 'R': 0.03571428571428571, 'S': 0.10714285714285714, 'T': 0.05357142857142857, 'V': 0.07142857142857142, 'W': 0.017857142857142856, 'Y': 0.03571428571428571}, 'fraction_disorder_promoting': 0.6964285714285714, 'Kappa': 0.288926080880985, 'Delta': 0.035572280194128926, 'Delta_max': 0.12311896553493187, 'Omega': 0.14024206278984358, 'mean_net_charge': np.float64(0.04281928020810004), 'mean_hydropathy': 3.7553571428571426, 'uversky_hydropathy': 0.41726190476190456, 'IDP_phase_state': 1, 'PPII_propensity': 0.39571428571428574}}
flatten_dict_to_featureDict(new_dict)
